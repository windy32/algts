Conceptual Overview
-------------------

The first thing we need to do before actually starting to look at or write algts scripts is to
explain a few core concepts and abstractions in the system. Much of this may appear transparently
obvious to some, but we recommend taking the time to read through this section just to ensure you
are starting on a firm foundation.

Key Abstractions
****************

In this section, we'll review some terms, which may be commonly used in networking, but have a
specific meaning in algts.

Gateway
+++++++

In Internet jargon, a gateway is a network point that acts as an entrance to another network.

Bacause algts is designed to study the link-sharing issue of residential gateways, it is assumed
that the upper layer ISP provides fixed quality service (which means a max download/upload rate), 
and ISP's shapers are working on both the upstream queue and the downstream queue even when the
last mile link is not really bottlenecked.

ISPs know that they are benchmarked solely on how fast people can download. Besides available
bandwidth, download speed is influenced heavily by packet loss, which seriously hampers TCP/IP
performance. Large queues can help prevent packet loss, and speed up downloads. So ISPs configure
large queues.

Therefore, ISP's shaper queue is critical in guaranteeing interactivity. A full-speed download
session may easily raise the queueing delay by hundreds of milliseconds while the upstream queue's
still empty most of the time. Uploaders in the local network may also damage interactivity, as for
an unsymmetry connection, e.g., DSL with an upstream rate at 256kbps, a single packet of 1500 bytes
need to wait about 50ms to be sent away.

Gateways studied in algts are faced with such problems that specific policies should be enforced at
the gateway in order to provide reasonable service to the users of the network.

Scenario
++++++++

A scenario is something that describes how local users make use of the network. 

Note that different scenarios implie different standards of quality. For a scenario where no user
runs realtime applications, fair division of download and upload bandwidth should be the only factor
concerned. However when realtime audio, video, or online game services are taken into consideration,
the balance between delay and throughput becomes the critical factor in optimizing your gateway.

Different scenario also implies different control level. For a network where users just enjoy online
games, you can even simply apply a FIFO queue, as realtime traffic generated by games is often
limited compared to the bandwitch available of your Internet connection. When bulk data pass the
gateway, however, more complex strategies should be introduced to get the same user experience.

Task
++++

A task in algts describes how users in a scenario use the network resource, it is abstraction of
the applications in the real world.

e.g., users may download large files through http or ftp, which is represented as a **bulk downlaod
task** in algts; users may want to upload attachments when visiting forums, which is represented as
a **bulk upload task**.

A task may have several attributes. For a bulk upload task or a bulk download task, the two
attributes supported are **MaxRate** and **MaxBytes**.

Client
++++++

A client in algts executes an algts task. It is abstraction of the application clients in the real
world.

e.g., for a bulk download task that belongs to user Harry, the client that corresponds to the task
should send a request saying "I want to download 10 megabytes' data, with a max rate of 180 KB/s".

A client is always associated with a specific task, and each task is associated with a user. When
we execute the test, multiple clients will be running at the same time, which is the same as the
situation in the real world.

Server
++++++

A server in algts processes requests from clients. It is abstraction of the application servers in
the real world.

Different types of servers process requests from different types of tasks. Note that a specific
server is not associated with a specific task, e.g., a bulk download server may send a file with a
size of 10 megabytes in response to the request from client A, and then send another file of 500
kilobytes in response to the request from client B, which is similar to an HTTP server in many ways.

Emulator
++++++++

The existance of ISP's shaper queues and wide area network characteristics such as packet delay, 
loss, reordering and corruption is important when optimizing the behaviors of the gateway.

Thus the emulator in algts is designed to emulate the existance of the elements above. In a linux
routers, we typically use token buckets for shaping, and use the netem qdisc for packet delay, 
loss, etc. The emulator in algts provides a and clean interface for setting up the emulation
environment without touching various implementation details.

A Sample algts Script
*********************

If you downloaded the system as was suggested above, you will have a release of algts in a directory
called **repos** under your home directory. Change into that release directory, and you should find
a directory structure something like the following:

::

    configure*   doxygen_index.h         gui/            server-daemon-build/
    core/        emulator-daemon/        Makefile        test-scripts/
    core-build/  emulator-daemon-build/  server-daemon/

Change into the **test-scripts** directory. You should see a file named **sample.cpp** located
there. This is a script that will create a simple scenario with two users. Let's take a look at
that script line by line, so go ahead and open **sample.cpp** in your favorite editor.

Boilerplate
+++++++++++

The algts suite is licensed using the GNU General Public License Version 2. You will see the
appropriate GNU legalese at the head of every file in the algts distribution. Often you will see
a copyright notice for one of the institutions involved in the algts project above the GPL text and
an author listed below.

::

    // Copyright (C) 2012 Gao Fengyu (feng32tc@gmail.com)
    //
    // This program is free software; you can redistribute it and/or modify
    // it under the terms of the GNU General Public License version 2 as
    // published by the Free Software Foundation;
    //
    // This program is distributed in the hope that it will be useful,
    // but WITHOUT ANY WARRANTY; without even the implied warranty of
    // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    // GNU General Public License for more details.
    //
    // You should have received a copy of the GNU General Public License
    // along with this program; if not, write to the Free Software
    // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

Module Includes
+++++++++++++++

The code proper starts with a include statement.

::

    #include "../core/core.h"

As algts is rather simple currently, headers necessary for scripting are simply put into one file
named **core.h**. You can use the single include file that recursively load all of the include files
used, rather than looking up exactly what header you need.

Main Function
+++++++++++++

The next lines of the script you will find are,

::

    int main (int argc, char *argv[])
    {

This is just the declaration of the main function of your program (script). Just as in any C++
program, you need to define a main function that will be the first function run. There is nothing
at all special here. Your algts script is just a C++ program.

The Console Application
+++++++++++++++++++++++

At the beginning of the main function, we create a console application.

::

    ConsoleApplication app(argc, argv);

In the "Setting Up Environment" section of previous chapter, we've seen that some settings like ip
addresses are fully configurable. We've selected 192.168.1.x as addresses for different users in a
standard or a hardware-in-the-loop environment, and selected 172.16.0.x for users in a pure virtual
environment.

The core application get necessary settings from command line parameters and validate the parameters
in a uniform way.

Logging
+++++++

The next line of the script is the following,

::

    Log::enable(Log::LOG_LEVEL_INFO);

We will use this statement as a convenient place to talk about our Doxygen documentation system. 
If you look at the project web site, `algts <http://algts.googlecode.com>`_, you will find a link
to "Downloads" in the navigation bar. If you select this link, you will be taken to the download
page. Click and download the api document for current release, (e.g., algts-0.0.2-api.chm).

Open the chm document with your chm viewer. Along the left side, you will find the structure
of the documentation. A good place to start is the **Modules** "book" in the algts navigation tree.
If you expand **Modules** you will see a list of algts module documentation. The algts logging
subsystem is discussed in the **C++ Constructs Used by All Modules** section, so go ahead and expand
that documentation node. Now, clink on the **Log** class.

You should now be looking at the Doxygen documentation for the Logging module. In the list of
"static public member functions" at the top of the page you will see the entry for **Log::enable**.
Before jumping in, it would probably be good to look for the "Detailed Description" of the logging
module to get a feel for the overall operation. You can either scroll down or select the "More..."
link under the collaboration diagram to do this.

Once you have a general idea of what is going on, go ahead and take a look at the specific
**Log::enable** documentation.  I won't duplicate the documentation here, but to summarize, this
line set the global logging level from warning level to information level.

Tracing
+++++++

In the next line, we enable the generation of trace file. The fisrt element in argv is passed into
function enable, so that the trace file will share the name of the script. For sample.cpp, the trace
file's name would be sample.trace.

::

    TextTrace::enable(argv[0]);

A trace file keeps the details of the tests, which is used for analyzing QoS strategies applied at
the gateway.

Terminal
++++++++

The following lines illustrate how to apply QoS strategies on your gateway.

::

    TelnetTerminal terminal("172.16.0.1");
    terminal.start();
    terminal.enter("root\n");
    terminal.enter("admin\n");
    terminal.enter("tc qdisc show\n"); // No QoS Script is available here
    terminal.close();

For a linux router, the QoS settings can always be represented as a shell script: you can create
a classful qdisc, add some classes to the qdisc, create some firewall rules, or even create a 
subscript that executes every one minute.

The terminal classes provide basic support for executing QoS scripts. As shown above, the script
in the sample just displays the qdisc settings on the gateway and does nothing else.

Emulator
++++++++

The next few lines sets up the emulator.

::

    BasicEmulator emulator("10.0.0.1", 3201);
    emulator.setParam("TxRate", "500kbps");
    emulator.setParam("RxRate", "2000kbps");
    emulator.commit();

We create a basic emulator, sets the downstream rate and upstream rate of ISP's shaper queues, and
finally commit settings.

A concrete emulator class represents a solution based on some certain implemenation details. The
basic emulator supports only two properties: **TxRate** and **RxRate**.

You may wonder why not add some more common properties, like TxDelay and RxDelay into the basic
emulator. Well, the reason involves various detials in the Linux operating system. To get the
desired throughput, a fair queue is often necessary, however in Linux, the stochastic fair queue
(sfq) and the netem are both classless qdiscs, which means that they cannot work together on a
certain interface. Therefore with netem/sfq/htb, it's impossible to emulate rate limit and delay
at the same time. However other solutions may still exist. More complex emulators providing richer
functionality are likely to be added to algts later.

Scenario
++++++++

Now we will get directly to the business of creating a scenario and running a test.

::

    // Setup scenario
    Scenario s(12345, 40); // seed & length
    s.addUser("Harry");
    s.addUser("Sally");
    
    s.addTask("Harry", new BulkDownloadTask(80));
    s.task()->setAttribute("MaxBytes", "2MB");
    s.task()->setAttribute("MaxRate", "2Mbps");
    
    s.addTask("Harry", new BulkUploadTask(80));
    s.task()->setAttribute("MaxBytes", "INFINITE");
    s.task()->setAttribute("MaxRate", "INFINITE");

    s.addTask("Harry", new OnoffDownloadTask(80));
    s.task()->setAttribute("OnTime", "Uniform 500, 10000");
    s.task()->setAttribute("OffTime", "Exponential 2000");
    s.task()->setAttribute("MaxRate", "INFINITE");
    s.task()->setAttribute("PacketSize", "1200B");
    s.task()->setAttribute("RequestSize", "50B");
    
    s.addTask("Sally", new TcpEchoTask(23));
    s.task()->setAttribute("InputSize", "Uniform 8, 8");
    s.task()->setAttribute("EchoSize", "Exponential 20, 1000");
    s.task()->setAttribute("Interval", "Pareto 500, 1.5, 10000");

    s.addTask("Sally", new AsyncUdpEchoTask(4000));
    s.task()-*>setAttribute("InputSize", "Uniform 10, 100");
    s.task()->setAttribute("EchoSize", "Uniform 10, 500");
    s.task()->setAttribute("Interval", "Pareto 600, 1.4");
    
We first create a scenario object, with a specific seed, and a length in seconds. Note that you
should pick a same seed along with a same scenario if you expect to get similar test results.

The length of the scenario is set to 40 seconds, which means you should wait for exactly 40 seconds
before the test is finished. 

Then we add two users into the scenario, and add tasks to a specific user. The script above is quite
straight forward:

We've created a bulk download task, a bulk upload task, and an on/off download task for user Harry,
and created a tcp echo task and an asynchronous udp echo task for user Sally. The servers for
harry's tasks are working at port 80. Harry's bulk download task has a limited transfer rate of
2Mbps (256 KB/s), which can be regarded as a result of server's transfer ability or packet loss in
the wide area network...

Note that some attributes can be random variables, you can find more details in the 
**RandomVariableFactory** page in our doxygen document.

Execute the Test
++++++++++++++++

What we need to do at this point is to actually run the test. This is done using the function
**exec** which is a member of the console application.

::

    app.exec(&s);

The console application will scan the scenario, create clients associated with the tasks, and
execute the clients so that they'll connect to servers and send requests.

The trace file is generated meanwhile, if the test executes successfully.

Reseting the emulator
+++++++++++++++++++++

After the test is done, we typically add one more line to reset the emulator. After reseting, the
default FIFO queue will be working on the server host once again.

::

    emulator.reset();

Building Your Script
++++++++++++++++++++

We have made it trivial to build your simple scripts. All you have to do is to execute the script
helper with a build option. Let's try it. Change into the **test-scripts** directory.

::

  cd test-scripts

Now build the sample script using script (helper):

::

  ./script --build sample

You should see messages reporting that your **sample** script was built successfully.

::

    [ALGTS SCRIPT] Generating sample.pro
    [ALGTS SCRIPT] Building script
    -----------------------------------------------------------------
    g++ -c -pipe -O2 -Wall -W -D_REENTRANT -DQT_NO_DEBUG -DQT_NETWORK_LIB -DQT_CORE_
    LIB -I../../../../qt/Desktop/Qt/4.8.0/gcc/mkspecs/default -I../../test-scripts -
    I../../../../qt/Desktop/Qt/4.8.0/gcc/include/QtCore -I../../../../qt/Desktop/Qt/
    4.8.0/gcc/include/QtNetwork -I../../../../qt/Desktop/Qt/4.8.0/gcc/include -I. -I
    ../../test-scripts -I. -o sample.o ../sample.cpp
    g++ -Wl,-O1 -Wl,-rpath,/home/feng32/qt/Desktop/Qt/4.8.0/gcc/lib -o sample sample
    .o    -L/home/feng32/qt/Desktop/Qt/4.8.0/gcc/lib ../../../bin/libcore.a -lQtNetw
    ork -lQtCore -lpthread 
    -----------------------------------------------------------------
    [ALGTS SCRIPT] Cleaning up

You can now run the example:

::

  ./sample 172.16.0.8/29 10.0.0.1 3200

If you have been following the tutorial closely, the server host and the gateway in virtual machine
probably have not been started yet, thus you may see the following output:

::

    Info: > 
    Info: < root
    Info: > 
    Info: > 
    Info: < admin
    Info: > 
    Info: > 
    Info: < tc qdisc show
    Info: > 
    Info: Parameter TxRate created with value 500kbps
    Info: Parameter RxRate created with value 2000kbps
    Error: Cannot connect to emulator daemon @ 10.0.0.1:3201
    Warning: Minimum value of EchoSize is less than 1B
    Error: No enough addresses available
    Error: Cannot connect to emulator daemon @ 10.0.0.1:3201

We try to telnet to the gateway, however no response is returned. As the **emulator.commit()**
executes, the emulator cannot connect to the daemon working on the server host that processes the
requests.

Now start the pure virual environment:

::

    cd ~
    sudo ./setup_tap.sh

Start the gateway in virtual machine, and then start the server host in virtual machine. When the
server host is ready, type the following command:

::

    cd ~
    sudo ./setup_servers.sh
    sudo ./emulatord 10.0.0.1 3201

Then press **Alt + F2**, enter the second terminal and type the following command:

::

    cd ~
    sudo ./serverd 10.0.0.1 3200 10.0.0.8/29

Finally, go back to your host operating system and execute the script again. There's an **--run**
option built in the script helper so that you can build and run the script in a single command:

::

    ./script --run sample "10.0.0.1 3200 10.0.0.8/29"

We can see that we've successfully telneted onto the gateway, the execution is successful and the
trace file is generated as expected:

::

    Info: > Trying 172.16.0.1...
    Info: > Connected to 172.16.0.1.
    Info: > Escape character is '^]'.
    Info: > 
    Info: > DD-WRT v24-sp2 std (c) 2010 NewMedia-NET GmbH
    Info: > Release: 06/12/10 (SVN revision: 14594)
    Info: > 
    Info: > DD-WRT login: 
    Info: < root
    Info: > root
    Info: > Password: 
    Info: > 
    Info: < admin
    Info: > 
    Info: > ==========================================================
    Info: >  
    Info: >  ____  ___    __        ______ _____         ____  _  _ 
    Info: >  | _ \| _ \   \ \      / /  _ \_   _| __   _|___ \| || | 
    Info: >  || | || ||____\ \ /\ / /| |_) || |   \ \ / / __) | || |_ 
    Info: >  ||_| ||_||_____\ V  V / |  _ < | |    \ V / / __/|__   _| 
    Info: >  |___/|___/      \_/\_/  |_| \_\|_|     \_/ |_____|  |_| 
    Info: >  
    Info: >                        DD-WRT v24-sp2
    Info: >                    http://www.dd-wrt.com
    Info: >  
    Info: > ==========================================================
    Info: > 
    Info: > 
    Info: > BusyBox v1.13.4 (2010-06-12 10:24:01 CEST) built-in shell (ash)
    Info: > Enter 'help' for a list of built-in commands.
    Info: > 
    Info: > root@DD-WRT:~# 
    Info: > 
    Info: < tc qdisc show
    Info: > tc qdisc show
    Info: > qdisc pfifo_fast 0: dev eth0 root bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
    Info: > qdisc pfifo_fast 0: dev eth1 root bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
    Info: > root@DD-WRT:~# 
    Info: Parameter TxRate created with value 500kbps
    Info: Parameter RxRate created with value 2000kbps
    Info: Parameters updated successfully
    Warning: Minimum value of EchoSize is less than 1B
    Info: Harry's address: 172.16.0.8
    Info: Sally's address: 172.16.0.9
    Info: Trace file generated successfully
    Info: Parameters successfully reset
    Info: Description: Emulator reset successfully

